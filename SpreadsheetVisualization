import os
import pandas as pd
from pyvis.network import Network

def get_font_color(background_color):
    # Define a dictionary mapping color names to their hex representations
    color_map = {
        'Red': '#FF0000',
        'White': '#FFFFFF',
        'Blue': '#0000FF',
        'Orange': '#FFA500'
        # Add more color mappings as needed
    }

    # Convert the background color to lowercase to handle different case variations
    background_color = background_color.lower()

    # Check if the color is in the color_map, if yes, return the corresponding font color
    if background_color in color_map:
        return '#FFFFFF' if color_map[background_color] != '#FFFFFF' else '#000000'

    try:
        # If not in color_map, treat it as a hexadecimal color and calculate perceived brightness
        r, g, b = tuple(int(background_color[i:i+2], 16) for i in (0, 2, 4))
        brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255

        # Use white font color for dark backgrounds and black font color for light backgrounds
        return '#FFFFFF' if brightness < 0.5 else '#000000'
    except ValueError:
        # If the color cannot be parsed as a hexadecimal, return a default font color
        return '#000000'

def main():
    # Prompt the user to enter the absolute file path of the CSV data
    data_path = input("Enter the absolute file path of the CSV data: ")

    # Remove surrounding double quotes if present
    data_path = data_path.strip('"')

    # Convert the file path to the appropriate format for the current operating system
    data_path = os.path.abspath(os.path.expanduser(data_path))
    print("Full file path:", data_path)  # Print the file path for debugging

    # Check if the file exists before reading the data
    if not os.path.exists(data_path):
        print("Error: File not found.")
    else:
        # Read the data from the CSV file into a Pandas DataFrame
        df = pd.read_csv(data_path)

        # Create a PyVis Network instance
        network = Network(height="1000px", width="1000px", notebook=True)

        # Size of the circles (nodes)
        circle_size = 30  # You can adjust this value as needed

        # Iterate through each row in the DataFrame
        for _, row in df.iterrows():
            from_name = row['From Name']
            to_name = row['To Name']
            party_name = row['Party Name']
            party_color = row['Party Color']
            strength_of_connection = row['Strength of Connection']
            trust_level = row['Trust Level']
            frequency_digital = row['Frequency_digital']
            frequency_physical = row['Frequency_physical']
            reference_sharing = row['Reference_Sharing']
            notes_sharing = row['Notes_Sharing']
            tier_from = row['Tier_from']
            tier_to = row['Tier_To']

            # Determine the font color based on the party_color
            font_color = get_font_color(party_color)

            # Add the nodes with the same size
            network.add_node(from_name, label=from_name, title=party_name, shape='circle', color=party_color, border='black', size=circle_size, **{"font": {"color": font_color}})
            network.add_node(to_name, label=to_name, title=party_name, shape='circle', color=party_color, border='black', size=circle_size, **{"font": {"color": font_color}})

            # Calculate edge thickness based on 'Strength of Connection' and 'Trust Level'
            edge_thickness = (strength_of_connection + trust_level) / 2

            # Combine the additional information for the edge tooltip
            edge_tooltip = f"Frequency_digital: {frequency_digital}<br>Frequency_physical: {frequency_physical}<br>Reference_Sharing: {reference_sharing}<br>Notes_Sharing: {notes_sharing}<br>Tier_from: {tier_from}<br>Tier_To: {tier_to}"

            # Add an edge between 'from' and 'to' names with thickness based on 'Strength of Connection' and 'Trust Level'
            network.add_edge(from_name, to_name, value=edge_thickness, color='black', title=edge_tooltip)

        # Show the network visualization
        network.show('network.html')

if __name__ == "__main__":
    main()
